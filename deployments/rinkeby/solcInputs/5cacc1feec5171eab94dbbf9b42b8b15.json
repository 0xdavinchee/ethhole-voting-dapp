{
  "language": "Solidity",
  "sources": {
    "contracts/Voting.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.7.0;\n\ncontract Voting {\n    struct Candidate {\n        address candidateAddress;\n        uint256 voteCount;\n        string name;\n    }\n    struct Voter {\n        bool voted;\n        uint256 candidateIndex;\n    }\n\n    uint256 public electionId;\n    uint256 public registrationEndPeriod;\n    uint256 public votingEndPeriod;\n    bool public locked;\n    address private owner;\n\n    Candidate[] public candidates;\n    mapping(address => mapping(uint256 => bool)) public registeredCandidates;\n    mapping(address => mapping(uint256 => Voter)) public voters;\n\n    event StartElection(\n        uint256 indexed _electionId,\n        uint256 _registrationEndPeriod,\n        uint256 _votingEndPeriod\n    );\n    event ArchivePastElection(\n        uint256 indexed _electionId,\n        string _winnerName,\n        uint256 _voteCount,\n        address _winnerAddress\n    );\n    event RegisterCandidate(string _name);\n    event VoteForCandidate(\n        uint256 indexed _candidateAddress,\n        uint256 _voteCount\n    );\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier noReentrancy() {\n        require(!locked, \"No reentrancy\");\n\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /**\n     * @dev startElection start a new election passing in a _registrationEndPeriod\n     * and a _votingEndPeriod. This also allows starting a new election if the\n     * conditions allow it.\n     */\n    function startElection(\n        uint256 _registrationEndPeriod,\n        uint256 _votingEndPeriod\n    ) external {\n        require(\n            _registrationEndPeriod >= block.timestamp &&\n                _votingEndPeriod >= _registrationEndPeriod,\n            \"Registration end period must be > voting end period > registration end period.\"\n        );\n        bool hasElectionEnded =\n            (registrationEndPeriod == 0 && votingEndPeriod == 0) ||\n                block.timestamp > votingEndPeriod;\n        require(\n            hasElectionEnded,\n            \"There is an active election currently, please wait until it is over.\"\n        );\n\n        // start a new election\n        if (registrationEndPeriod != 0 || votingEndPeriod != 0) {\n            (string memory name, uint256 voteCount, address winnerAddress) =\n                winningCandidateDetails();\n            emit ArchivePastElection(\n                electionId,\n                name,\n                voteCount,\n                winnerAddress\n            );\n            delete candidates;\n            electionId++;\n        }\n\n        registrationEndPeriod = _registrationEndPeriod;\n        votingEndPeriod = _votingEndPeriod;\n\n        emit StartElection(\n            electionId,\n            _registrationEndPeriod,\n            _votingEndPeriod\n        );\n    }\n\n    /**\n     * @dev registerCandidate allows anyone to sign up as a candidate in an\n     * active election.\n     */\n    function registerCandidate(string memory _name) external {\n        require(\n            registrationEndPeriod != 0,\n            \"There are no elections currently.\"\n        );\n        require(\n            getKeccak(_name) != getKeccak(\"\"),\n            \"Please register with a name.\"\n        );\n        require(\n            block.timestamp < registrationEndPeriod,\n            \"The registration period has ended.\"\n        );\n        require(\n            registeredCandidates[msg.sender][electionId] == false,\n            \"You have already registered for an election.\"\n        );\n        registeredCandidates[msg.sender][electionId] = true;\n        candidates.push(Candidate(msg.sender, 0, _name));\n\n        emit RegisterCandidate(_name);\n    }\n\n    /**\n     * @dev voteForCandidate allows anyone to vote for a candidate in the current\n     * active election.\n     */\n    function voteForCandidate(uint256 _candidateId) external noReentrancy {\n        require(\n            !voters[msg.sender][electionId].voted,\n            \"You have already voted for a candidate.\"\n        );\n        require(\n            candidates.length >= _candidateId + 1,\n            \"This candidate doesn't exist.\"\n        );\n        require(\n            block.timestamp > registrationEndPeriod &&\n                block.timestamp < votingEndPeriod,\n            \"Voting is not allowed now.\"\n        );\n        candidates[_candidateId].voteCount++;\n        voters[msg.sender][electionId].voted = true;\n        voters[msg.sender][electionId].candidateIndex = _candidateId;\n\n        emit VoteForCandidate(_candidateId, candidates[_candidateId].voteCount);\n    }\n\n    /**\n     * @dev getLiveResults a view function to see the current results\n     * active election.\n     */\n    function getLiveResults()\n        external\n        view\n        returns (address[] memory, uint256[] memory, uint256)\n    {\n        address[] memory addresses = new address[](candidates.length);\n        uint256[] memory voteCounts = new uint256[](candidates.length);\n\n        for (uint256 i = 0; i < candidates.length; i++) {\n            addresses[i] = candidates[i].candidateAddress;\n            voteCounts[i] = candidates[i].voteCount;\n        }\n        return (addresses, voteCounts, votingEndPeriod);\n    }\n\n    /**\n     * @dev getWinnerResults a view function to see who the winner of the\n     * active election is.\n     */\n    function getWinnerResults()\n        public\n        view\n        returns (uint256 _winningCandidate, bool isOver)\n    {\n        uint256 winningCount = 0;\n        isOver = block.timestamp > votingEndPeriod;\n\n        for (uint256 i = 0; i < candidates.length; i++) {\n            if (candidates[i].voteCount > winningCount) {\n                winningCount = candidates[i].voteCount;\n                _winningCandidate = i;\n            }\n        }\n    }\n\n    function destroyContract() public {\n        require(msg.sender == owner);\n        selfdestruct(msg.sender);\n    }\n\n    /**\n     * @dev winningCandidateDetails an internal view function to get the details of the\n     * winning candidate.\n     */\n    function winningCandidateDetails()\n        internal\n        view\n        returns (\n            string memory _name,\n            uint256 _voteCount,\n            address _address\n        )\n    {\n        (uint256 winningCandidate, ) = getWinnerResults();\n        return (\n            candidates[winningCandidate].name,\n            candidates[winningCandidate].voteCount,\n            candidates[winningCandidate].candidateAddress\n        );\n    }\n\n    function getKeccak(string memory _string) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_string));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}